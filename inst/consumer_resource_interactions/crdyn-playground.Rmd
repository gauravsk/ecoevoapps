---
title: "Consumer-Resource Dynamics"
author: "Madeline Cowen and Rosa M. McGuire"
output: html_document
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(ggplot2)
library(tidyr)
library(purrr)
library(dplyr)
library(deSolve)
library(ecoevoapps)
library(patchwork)
library(RColorBrewer)
library(kableExtra)
ggplot2::theme_set(ecoevoapps::theme_apps())
```


This app presents several models that can be used to simulate the dynamics of consumers and biotic resources (e.g. predators and their prey, herbivores and plants, parasitoids and their hosts, etc. We refer to the resource as "prey" and the consumer as "predator". 

There are several variants of the general consumer-resource model that are presented here. The first tab presents the classic Lotka-Volterra predator prey model, and the other tabs all present variations on this classic model that add various aspects of biological reality. 


##  {.tabset}


```{r consumer resource functions, include=FALSE}

## EQ FOR SINGLE TIMESTEP CALCULATIONS -------

# exponential growth, type I
lv_pred1_eq <- function(H, P, pars) {
  
  with (as.list(pars), {
    # description of parameters:
    # r = per capita growth rate (prey)
    # a = attack rate 
    # e = conversion efficiency
    # d = predator death rate 
    
    dH_dt = r*H - (a*H*P)
    dP_dt = e*(a*H*P) - d*P
    
    return(data.frame(dH = dH_dt, dP = dP_dt))
  
  })
}

# Logistic prey

logprey_eq <- function(H, P, pars) {
  
  with (as.list(pars), {
    # description of parameters:
    # r = per capita growth rate (prey)
    # a = attack rate 
    # e = conversion efficiency
    # d = predator death rate 
    # K = carrying capacity of the prey
    
    dH_dt = r*H*(1 - H/K) - (a*H*P)
    dP_dt = e*(a*H*P) - d*P
    
    return(data.frame(dH = dH_dt, dP = dP_dt))
  
  })
}

# Type II Functional Response

lv_pred2_eq <- function(H, P, pars) {
  with (as.list(pars), {
    # description of parameters:
    # r = per capita growth rate (prey)
    # a = attack rate 
    # T_h = handling time
    # e = conversion efficiency
    # d = predator death rate 
    
    dH_dt = r*H - (a*H*P)/(1 + a*T_h*H)
    dP_dt = e*(a*H*P)/(1 + a*T_h*H) - d*P
    
    return(data.frame(dH = dH_dt, dP = dP_dt))
  
  })
}

# Rosenzweig-MacArthur Model

rm_predation_eq <-function(H, P, pars) {
  with (as.list(pars), {
    # description of parameters:
    # r = per capita growth rate (prey)
    # K = prey carrying capacity
    # a = attack rate 
    # T_h = handling time
    # e = conversion efficiency
    # d = predator death rate 
    
    dH_dt = r*H*(1 - H/K) - (a*H*P)/(1 + a*T_h*H)
    dP_dt = e*(a*H*P)/(1 + a*T_h*H) - d*P
    
    return(data.frame(dH = dH_dt, dP = dP_dt))
    
  })
}

## make function to generate data for vector field/phase plane -------

vector_field_input <- function(sim_df, eq_func, pars_for_eq_func, vec_density = 20) {

  # INPUTS
  # sim_df is a df with the simulated values of H & P in separate columns
  # eq_func is the function with the system of equations that calculate dH and dP for one time step
  # pars_for_eq_func is the vector of named parameters to use in the eq_func
  # vec_density determines the number of arrows (vec_density^2)

  # OUTPUT:
  # a df with Hstart, Hend, Pstart, Pend (and dH, dP) for drawing vectors

  # BODY:
  # add error checks here

  # determine the min and max of the number of prey and predators
  lowH <- round(min(sim_df$H), 0)
  hiH <- round(max(sim_df$H), 0)
  lowP <- round(min(sim_df$P), 0)
  hiP <- round(max(sim_df$P), 0)

  # select a sequence of points between (and a little beyond) those values
  seqH <- seq(0.9*lowH, 1.4*hiH, length.out = vec_density)
  seqP <- seq(0.9*lowP, 1.4*hiP, length.out = vec_density)

  # find all the combinations of those H and P coordinates, make that a df w/Hstart and Pstart
  hpcoords <- expand.grid(Hstart = seqH, Pstart = seqP)

  # use those values to solve dP and dH and calculate pend and hend
  hpcoords <- bind_cols(hpcoords, map2_df(hpcoords$Hstart, hpcoords$Pstart, eq_func, pars_for_eq_func))
  hpcoords <- hpcoords %>% mutate(Hend = Hstart + dH, Pend = Pstart + dP)

  return(hpcoords)
}


# function to make the vector field with ggplot ------
plot_preprey_vector_field <- function(sim_df, vector_field_input_data) {

  # INPUT
  # sim_df is a df with the simulated values of H & P in separate columns
  # vector_field_input_data has the output from vector_field_input, which is a list of start and end coordinates for each vector segment

  # OUTPUT
  # is a ggplot

  ggplot(sim_df) +

    # vector field
    geom_segment(data = vector_field_input_data,
                 aes(x = Hstart, y = Pstart, xend = Hend, yend = Pend),
                 arrow = arrow(length = unit(0.02, "npc")),
                 color = "light gray")

}


```

### Lotka-Volterra predator-prey model

Equations describing prey that grows exponentially and predators that consume the prey following a Type I functional response:

\[
\begin{align}
\frac{dH}{dt} &= rH - aHP\\
\\
\frac{dP}{dt} &= eaHP - dP
\end{align}
\]

```{r params type 1, echo=F}
pars_vars <- c("$H$", 
               "$P$", 
               "$r$", 
               "$a$", 
               "$e$", 
               "$d$")
descriptions <- c("Population size of the prey",
                 "Population size of the predator",
                 "Per capita growth rate of the prey",
                 "Attack rate of the predator",
                 "Conversion efficiency of the predator",
                 "Death rate of the predator")
param_df <- data.frame(pars_vars, descriptions)
kable(x = param_df, format = "html", 
      col.names = c("Parameter/Variable", "Description")) %>%
  kable_styling(full_width = FALSE, 
                bootstrap_options = c("striped", "hover", "condensed"),
                position = "center")
```  

Equations for the zero net growth isoclines:
\[
\begin{align}
P^* &= \frac{r}{a}\\
\\
H^* &= \frac{d}{ea} 
\end{align}
\]


```{r type 1 pred prey, echo=FALSE}
sidebarLayout(
  sidebarPanel(
    ### Ask users for parameter values ----
    ## r, a, T_h, e, d
    
    sliderInput("r_lv_pred1", label = "Per capita growth rate of Prey", min = .0001, max = 1.0, value = .5),
    sliderInput("a_lv_pred1", label = "Predator attack rate", min = .001, max = 1.0, value = .1),
    sliderInput("e_lv_pred1", label = "Predator conversion efficiency", min = .001, max = 1.0, value = 0.2),
    sliderInput("d_lv_pred1", label = "Per capita death rate of Predator", min = .0001, max = 1.0, value = .3),
    
    ### Ask users for initial conditions -----
    #N1, N2
    
    numericInput("H_lv_pred1", label = "Initial population size of Prey", min = 1, value = 10),
    numericInput("P_lv_pred1", label = "Initial population size of Predator", min = 1, value = 10),
    
    ### Ask users for time to simulate ----
    numericInput("t_lv_pred1", label = "Timesteps", min = 1, value = 100),
    
    checkboxGroupInput("vectors_lv_pred1", label = "Display vector field?", 
                       choices = c("Yes" = "Yes"), selected = "Yes")
    
  ),  
  
 
  mainPanel(renderPlot(plot_lvpred1()),
            renderPlot(np_lvpred1())
            # renderPlot(dabund_plot_lv_pred1())
            )

)

# Set the initial population sizes
init_lv_pred1 <- reactive({c(H = input$H_lv_pred1 , P = input$P_lv_pred1)})

# Set the parameter values
pars_lv_pred1 <- reactive({
  c(r = input$r_lv_pred1, a = input$a_lv_pred1 , e = input$e_lv_pred1, d = input$d_lv_pred1)
})

# Time over which to simulate model dynamics
time_lv_pred1 <- reactive({seq(0, input$t_lv_pred1, by = .1)})

# simulate model dynamics
out_lv_pred1 <- reactive({
  data.frame(ecoevoapps::run_predprey_model(
    time = time_lv_pred1(),
    init = init_lv_pred1(),
    params = pars_lv_pred1()
  ))
})
  
# Reshape the data for plotting


# Plots ------
## make abundance thru time plot
plot_lvpred1 <- reactive({
  # Make a long df for easier plotting
  out_long_lv_pred1 <- pivot_longer(out_lv_pred1(), c(H,P), "Population")
  ggplot(out_long_lv_pred1) + 
    geom_line(aes(x = time, y = value, color = Population), size = 2) + 
    scale_color_brewer(palette = "Set1") +
    ylab("Population size") 
})

## make isocline plot and add vector field depending on user input
vec_input_lv_pred1 <- reactive({
  vector_field_input(sim_df = out_lv_pred1(), eq_func = lv_pred1_eq,
                     pars_for_eq_func = pars_lv_pred1())
})

np_lvpred1 <- reactive({
  if("Yes" %in% input$vectors_lv_pred1) {
    plot_vector_field(out_lv_pred1(), pars_lv_pred1()) +
      
      # the isoclines
      geom_hline(yintercept = input$r_lv_pred1/input$a_lv_pred1, 
                 col = brewer.pal(n = 3, name = "Set1")[1], size = 2) +
      geom_vline(xintercept = input$d_lv_pred1/(input$e_lv_pred1*input$a_lv_pred1),
                 col = brewer.pal(n = 3, name = "Set1")[2], size = 2) +
      
      # the trace of the simulation and arrow for direction of the trace
      geom_path(aes(x = H, y = P), size = 2) +
      geom_segment(x = out_lv_pred1()$H[min(5, round(length(time_lv_pred1()))/50)], #did this min thing in case someone asks for very few timesteps
                   y = out_lv_pred1()$P[min(5, round(length(time_lv_pred1()))/50)],
                   xend = out_lv_pred1()$H[min(5 + 1, round(length(time_lv_pred1())/50) + 1)],
                   yend = out_lv_pred1()$P[min(5 + 1, round(length(time_lv_pred1())/50) + 1)],
                   arrow = arrow(length = unit(0.1, "npc")),
                   cex = 2) +
      
      # plot appearance
      xlab("Number of Prey") +
      ylab("Number of Predators") +
      coord_cartesian(xlim = c(min(out_lv_pred1()$H), max(out_lv_pred1()$H) + 1), 
                      ylim = c(min(out_lv_pred1()$P), max(out_lv_pred1()$P) + 1))  #need this line to show all vectors that go beyond plot limits
    
  } else {
    
    ggplot(out_lv_pred1()) +
      # the isoclines
      geom_hline(yintercept = input$r_lv_pred1/input$a_lv_pred1, 
                 col = brewer.pal(n = 3, name = "Set1")[1], size = 2) +
      geom_vline(xintercept = input$d_lv_pred1/(input$e_lv_pred1*input$a_lv_pred1), 
                 col = brewer.pal(n = 3, name = "Set1")[2], size = 2) +
      
      # the trace of the simulation and arrow for direction of the trace
      geom_path(aes(x = H, y = P), size = 2) +
      geom_segment(x = out_lv_pred1()$H[min(5, round(length(time_lv_pred1()))/50)], #did this min thing in case someone asks for very few timesteps
                   y = out_lv_pred1()$P[min(5, round(length(time_lv_pred1()))/50)],
                   xend = out_lv_pred1()$H[min(5 + 1, round(length(time_lv_pred1())/50) + 1)],
                   yend = out_lv_pred1()$P[min(5 + 1, round(length(time_lv_pred1())/50) + 1)],
                   arrow = arrow(length = unit(0.1, "npc")),
                   cex = 2) +
      
      # plot appearance
      xlab("Number of Prey") +
      ylab("Number of Predators") +
      coord_cartesian(xlim = c(min(out_lv_pred1()$H), max(out_lv_pred1()$H) + 1),
                      ylim = c(min(out_lv_pred1()$P), max(out_lv_pred1()$P) + 1)) #need this line to show all vectors that go beyond plot limits

  }
  
})

```
